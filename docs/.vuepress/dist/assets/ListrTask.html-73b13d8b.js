import{_ as r,W as o,X as d,Y as e,Z as n,a2 as s,$ as t,a5 as i,D as c}from"./framework-4c9bc095.js";const h={},l=e("h1",{id:"interface-listrtask-ctx-renderer",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#interface-listrtask-ctx-renderer","aria-hidden":"true"},"#"),t(" Interface: ListrTask<Ctx, Renderer>")],-1),p=e("p",null,"ListrTask.",-1),f=e("p",null,"Defines the task, conditions and options to run a specific task in the listr.",-1),u=e("h2",{id:"type-parameters",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#type-parameters","aria-hidden":"true"},"#"),t(" Type parameters")],-1),_=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"left"}},"Name"),e("th",{style:{"text-align":"left"}},"Type")])],-1),k=e("td",{style:{"text-align":"left"}},[e("code",null,"Ctx")],-1),b={style:{"text-align":"left"}},x=e("code",null,"ListrContext",-1),g=e("td",{style:{"text-align":"left"}},[e("code",null,"Renderer")],-1),m={style:{"text-align":"left"}},y=e("code",null,"ListrRendererFactory",-1),T=e("code",null,"any",-1),L=i('<h2 id="properties" tabindex="-1"><a class="header-anchor" href="#properties" aria-hidden="true">#</a> Properties</h2><h3 id="title" tabindex="-1"><a class="header-anchor" href="#title" aria-hidden="true">#</a> title</h3><p>• <code>Optional</code> <strong>title</strong>: <code>string</code></p><p>Title of the task.</p><p>Give this task a title if you want to track it by name in the current renderer.</p><p>Tasks without a title will hide in the default renderer and are useful for running a background instance. On verbose renderer, state changes from these tasks will log as &#39;Task without a title.&#39;</p><h4 id="defined-in" tabindex="-1"><a class="header-anchor" href="#defined-in" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:25</p><hr><h3 id="task" tabindex="-1"><a class="header-anchor" href="#task" aria-hidden="true">#</a> task</h3>',10),v=e("strong",null,"task",-1),w=e("code",null,"ListrTaskFn",-1),O=e("code",null,"Ctx",-1),R=e("code",null,"Renderer",-1),C=i('<p>The task itself.</p><p>Task can be a sync or async function, an Observable, or a Stream. Task will be executed, if the certain criteria of the state are met and whenever the time for that specific task has come.</p><h4 id="defined-in-1" tabindex="-1"><a class="header-anchor" href="#defined-in-1" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:32</p><hr><h3 id="skip" tabindex="-1"><a class="header-anchor" href="#skip" aria-hidden="true">#</a> skip</h3><p>• <code>Optional</code> <strong>skip</strong>: <code>string</code> | <code>boolean</code> | (<code>ctx</code>: <code>Ctx</code>) =&gt; <code>string</code> | <code>boolean</code> | <code>Promise</code>&lt;<code>string</code> | <code>boolean</code>&gt;</p><p>Skip this task depending on the context.</p><p>The function that has been passed in will be evaluated at the runtime when the task tries to initially run.</p><h4 id="defined-in-2" tabindex="-1"><a class="header-anchor" href="#defined-in-2" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:38</p><hr><h3 id="enabled" tabindex="-1"><a class="header-anchor" href="#enabled" aria-hidden="true">#</a> enabled</h3><p>• <code>Optional</code> <strong>enabled</strong>: <code>boolean</code> | (<code>ctx</code>: <code>Ctx</code>) =&gt; <code>boolean</code> | <code>Promise</code>&lt;<code>boolean</code>&gt;</p><p>Enable a task depending on the context.</p><p>The function that has been passed in will be evaluated at the initial creation of the Listr class for rendering purposes, as well as re-evaluated when the time for that specific task has come.</p><h4 id="defined-in-3" tabindex="-1"><a class="header-anchor" href="#defined-in-3" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:45</p><hr><h3 id="retry" tabindex="-1"><a class="header-anchor" href="#retry" aria-hidden="true">#</a> retry</h3><p>• <code>Optional</code> <strong>retry</strong>: <code>number</code></p><p>Adds the given number of retry attempts to the task if the task fails.</p><h4 id="defined-in-4" tabindex="-1"><a class="header-anchor" href="#defined-in-4" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:49</p><hr><h3 id="rollback" tabindex="-1"><a class="header-anchor" href="#rollback" aria-hidden="true">#</a> rollback</h3>',26),D=e("code",null,"Optional",-1),F=e("strong",null,"rollback",-1),N=e("code",null,"ListrTaskFn",-1),P=e("code",null,"Ctx",-1),B=e("code",null,"Renderer",-1),E=i('<p>Runs a specific event if the current task or any of the subtasks has failed.</p><p>Mostly useful for rollback purposes for subtasks. But can also be useful whenever a task is failed and some measures have to be taken to ensure the state is not changed.</p><h4 id="defined-in-5" tabindex="-1"><a class="header-anchor" href="#defined-in-5" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:56</p><hr><h3 id="exitonerror" tabindex="-1"><a class="header-anchor" href="#exitonerror" aria-hidden="true">#</a> exitOnError</h3><p>• <code>Optional</code> <strong>exitOnError</strong>: <code>boolean</code> | (<code>ctx</code>: <code>Ctx</code>) =&gt; <code>boolean</code> | <code>Promise</code>&lt;<code>boolean</code>&gt;</p><p>Set exit on the error option from task-level instead of setting it for all the subtasks.</p><h4 id="defined-in-6" tabindex="-1"><a class="header-anchor" href="#defined-in-6" aria-hidden="true">#</a> Defined in</h4><p>src/interfaces/task.interface.ts:60</p><hr><h3 id="options" tabindex="-1"><a class="header-anchor" href="#options" aria-hidden="true">#</a> options</h3>',12),S=e("code",null,"Optional",-1),V=e("strong",null,"options",-1),G=e("code",null,"ListrGetRendererTaskOptions",-1),I=e("code",null,"Renderer",-1),A=e("p",null,"Per task options, that depends on the selected renderer.",-1),M=e("p",null,"These options depend on the implementation of the selected renderer. If the selected renderer has no options it will be displayed as never.",-1),W=e("h4",{id:"defined-in-7",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#defined-in-7","aria-hidden":"true"},"#"),t(" Defined in")],-1),X=e("p",null,"src/interfaces/task.interface.ts:67",-1);function Y(Z,$){const a=c("RouterLink");return o(),d("div",null,[l,p,f,u,e("table",null,[_,e("tbody",null,[e("tr",null,[k,e("td",b,[n(a,{to:"/api/types/ListrContext.html"},{default:s(()=>[x]),_:1})])]),e("tr",null,[g,e("td",m,[t("extends "),n(a,{to:"/api/types/ListrRendererFactory.html"},{default:s(()=>[y]),_:1}),t(" = "),T])])])]),L,e("p",null,[t("• "),v,t(": "),n(a,{to:"/api/types/ListrTaskFn.html"},{default:s(()=>[w]),_:1}),t("<"),O,t(", "),R,t(">")]),C,e("p",null,[t("• "),D,t(),F,t(": "),n(a,{to:"/api/types/ListrTaskFn.html"},{default:s(()=>[N]),_:1}),t("<"),P,t(", "),B,t(">")]),E,e("p",null,[t("• "),S,t(),V,t(": "),n(a,{to:"/api/types/ListrGetRendererTaskOptions.html"},{default:s(()=>[G]),_:1}),t("<"),I,t(">")]),A,M,W,X])}const q=r(h,[["render",Y],["__file","ListrTask.html.vue"]]);export{q as default};
